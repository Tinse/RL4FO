reward1 = -self.val  # 新状态函数值的绝对大小
reward2 = self.last_val - self.val  # 当前动作的改进幅度
reward3 = self.last_best_val - self.best_value   # 最优值的改进幅度
reward = (self.last_val - self.val) + (-self.val) + (self.last_best_val - self.best_value)  # 三者的综合

reward1 对简单(低维度/少局部最优解)的函数效果好,对复杂函数效果差,缺乏动作信息,奖励尺度不稳定,但利用了最根本的信息
reward2 对复杂函数效果好,可能导致贪婪短视,但局部探索能力强
reward3 对复杂函数效果好,特点是奖励稀疏,但全局探索能力强

下一步短步长下结果的对比

PPO算法
对sphered函数,1-2-6-12维函数都能逐渐趋于收敛，奖励为函数值,固定起始【6.0】，步长0.1，步数100，其他参数默认，12维接近收敛训练步数72w
对ackley函数,1-4-12维函数都能逐渐趋于收敛，奖励为函数值,固定起始【6.0】，步长0.1，步数100，其他参数默认，12维接近收敛训练步数50w
对rastrigin函数，12维固定起始点，经历100w步趋于近优，仍有3个维度还未接近最优解，将奖励修改为综合后，100w步完全
收敛
对于levyh函数，12维固定点无法找到最优解，1000w都没有收敛

SAC算法相对PPO效果更好，但依然无法使levy函数收敛到最优解

尝试mask降低动作空间

需要实验步长对收敛的影响

# 2025年3月27日21:59:08

50w步找到12维levy函数最优解,在离散动作-1和+1，步长0.1，步数限制1000，每次初始位置修改为当前最优解，学习率1e-4，甚至可以在任意初始状态寻找到最优解
0327PPO_dis_12dim_levy_step01_max100000_reward_reset_690000_steps.zip
tensorboard --logdir="./PPO_102"

# 2025年3月28日00:10:36

## 最大步长的影响：

最大步长决定了当前解在重置解周围能够探索邻域的大小，决定了每次重置后探索的可能情况的多少即探索空间的大小，因此对探索效率有很大影响，进而对收敛速度有显著的影响

### 最大步长小：

#### 优点：

最大步长小对非局部最优解，收敛最快，因为只探索一步，可能出现的情况少，探索空间小，很快就能找到下一次更优解。

#### 缺点：

最大步长小对局部最优解，需要足够步长才能跳出局部最优解的范围找到更优秀解，因此会陷入局部最优解

### 最大步长大：

#### 优点：

最大步长大对局部最优解，有足够大的步长跳出局部最优解的范围找到更优秀解，因此不会陷入局部最优解。

#### 缺点：

最大步长大对非局部最优解，如果第一步探索方向错误了，需要探索更多的步数才有可能找到更优解或纠正第一步的探索方向，后面的步数如果没有纠正且找到更优解，就属于浪费了。且相对于只探索一步，探索空间大，导致收敛慢。

即使前n步探索方向正确，不断找到新的更优解，这也与只探索一步速度一致。（当前在最新的更优解）如果第n+1步的方向错误，那么需要更多的步数去纠正，后面的步数如果没有纠正且找到更优解，就属于浪费了。**因此对于非局部最优解，只要探索错误就会出现浪费。**



### 按是否为局部最优解讨论：
对于非局部最优解，采取最大步长为1收敛最快（仅针对找到下一个更优解）。

对于局部最优解，假设至少需要m步(最近距离)，采取最大步长为n∝αm²收敛最快。其中α与维数d成反比,而与m²成正比
例如1维情况下:n≈0.706m^2

因此理论上最好的策略是,对于非局部最优解(梯度不为0),最大步长应设置为1。对于局部最优解，最大步长应设置为跳出局部最优解m步长的函数αm²步。
### 最大步数分析总结
但是算法在执行过程中，没有梯度信息，无法确认是否为局部最优解，只知道当前已经探索的步数和是否找到新的更优解。如果将“局部最优解”误认为“非局部最优解”，那么步长过小，无法跳出范围，找不到下一个更优解。如果将“非局部最优解”误认为“局部最优解”，那么步长过大，大大降低了探索效率。

从全局的角度来讲，步数较大时，在“非局部最优解”探索时，它可能直接跳出最近的“局部最优解”范围，因此不能说步数大完全没有好处。更重要的是：对于一个函数的“非局部最优解”远多于“局部最优解”，加上探索能力，几乎绝大多数情况是“非局部最优解”。

核心矛盾在于当前n步后未找到更优解，“非局部最优解”只需1步就停止，探索效率最高；而“局部最优解”需要达到一定步数m后，才有跳出的可能性，等于αm²时探索效率最高。相同的情况下，需要不同的处理。
关键在于如何设置合理的最大步数确保二种情况的效率最大化或者牺牲最小化。因此需要动态调整的最大步数，而非一成不变的最大步数。换句说法，关键在于如何区分当前是否为局部最优解。

### 实现思路
关键点：在“非局部最优解”随机方向探索1步（步长较小，主要考虑与梯度的夹角）得到更优解的概率越为50%，连续失败p次是概率是1/2^p。如阈值p设置为5，则当前点只有3%的概率为“非局部最优解”。
1. 无穷最大步长：不设置最大步长，只有当找到新的更优解才会重置环境。相当于无限步长，确保不会限制在局部最优解，但简单粗暴的行为导致“非局部最优解”探索效率极低，而对于一个函数往往“非局部最优解”远多于“局部最优解” ，而且当初始策略较差时，初始方向不正确时，需要很久才能纠正错误。
这个方法，简单粗糙，但基本上能从理论上确保一定能跳出局部最优解。
2. 动态最大步长n：默认最大步长为1，记录未找到更优解的步数u，u越大说明它是“局部最优解”的可能性越大，因此需要增大最大步长n，需要推导一个根据u来修改n的逻辑，为了照顾适用性，应该根据被优化函数的特性来确定。如函数没有距离较远的局部最优解，则n可以小一点，或封顶在某个值，避免无止境增加降低效率。
这个方法，可以非常灵活地定制，自由度最高，理论上最能在概率上达到最大的效率。如果n没有封顶，则可以确保理论上一定能跳出所有局部最优解。
3. 极端法：默认最大步长为1，当未找到更优解的步数u超过某个阈值p(如p=5)时，根据函数特性确定一个最大步长n(确保足够跳出局部最优解)。
这个方法，需要设定的参数少，只有p和n，建议p设置不要太大，而n尽量大，因为n需要确保能跳出局部最优解。如果函数跳出局部最优解的所需的步长n变化范围很大，这时更适合采用“2. 动态最大步长n”。n不够大时，会必然陷入局部最优解。
4. 随机法：不使用完全确定的步长，以一定的概率选择1步，一定概率选择n步，，，，概率可以根据未找到更优解的步数u来调节。
这个方法，通过概率的随机性兼顾两种情况，还可以根据u来调节概率，也非常灵活，可以牺牲一定的探索效率确保不会陷入局部最优解。

5. 超梯度（一般用于调节学习率）
6. 信赖域构建局部模型


# 11:12
测试12维sphere函数时，最大步长过小（为2），出现了找到了最优解，但不能让任意初始解收敛于最优解。

# 2025年3月28日16:06:17
阈值p应该很大，因为1步探索很快。变为探索模式后p应该小，而增长倍率不要过大

# 2025年3月28日21:04:58
为什么不直接变步长？变步长可以避免斡旋，仍然采用单步搜索减小探索空间。